using Microsoft.EntityFrameworkCore.Migrations;

namespace EFSamples.Migrations
{
	public partial class MigGrade : Migration
	{
		// Manual database manipulation in the Up/Down methods based on the following:
		// https://sqlite.org/lang_altertable.html#otheralter 
		// https://www.techonthenet.com/sqlite/foreign_keys/foreign_keys.php 
		// https://elanderson.net/2017/04/entity-framework-core-with-sqlite-migration-limitations/ 
		// SQL synax tutorial: https://www.w3schools.com/sql/default.asp 
		protected override void Up(MigrationBuilder migrationBuilder)
		{
			migrationBuilder.CreateTable(
				name: "Grades",
				columns: table => new
				{
					Id = table.Column<int>(nullable: false)
						.Annotation("Sqlite:Autoincrement", true),
					Name = table.Column<string>(nullable: true),
					Section = table.Column<string>(nullable: true)
				},
				constraints: table =>
				{
					table.PrimaryKey("PK_Grades", x => x.Id);
				});

#if false
            // This won't work because EFCore does not support AddForeignKey.
            migrationBuilder.AddColumn<int>(
                name: "GradeId",
                table: "Students",
                nullable: false,
                defaultValue: 0);

            migrationBuilder.CreateIndex(
                name: "IX_Students_GradeId",
                table: "Students",
                column: "GradeId");

            migrationBuilder.AddForeignKey(
                name: "FK_Students_Grades_GradeId",
                table: "Students",
                column: "GradeId",
                principalTable: "Grades",
                principalColumn: "Id",
                onDelete: ReferentialAction.Cascade);
#endif
			// We are adding a non-nullable foreign key to Students.
			// This means that each Student MUST have a relationship
			// with a Grade. However, there are no Grades because we
			// just created that table. There is no way for the app
			// to know what Grades the user might have, and we can't
			// ask for that info here. There are two choices:
			// 1. Make the foreign key nullable. This could work here
			//    because a case could be made that a Student does not
			//    need to always have a Grade (they could be in between
			//    grades; they could be new to the school and not yet
			//    assigned a grade).
			// 2. Create a default Grade and assign all existing
			//    Students to it. This could work because having a
			//    default value is fairly common.
			// Either way, the user will need to go through the list
			// of Students and set their Grade correctly (after 
			// creating the Grades in the first place).
			// For sample purposes, I am going to go with option 2
			// here. Maybe in the future I will extend the sample
			// to cover option 1 as well.
			migrationBuilder.Sql(
				@"INSERT INTO Grades VALUES (1, 'Default Grade Name', 'Default Grade Section');"
			);

			// Copy the existing table data to a temp table.
			migrationBuilder.Sql(
				@"PRAGMA foreign_keys = off;

				  CREATE TABLE TEMP_Students AS SELECT *
				                                FROM Students;

				  ALTER TABLE TEMP_Students
				  ADD GradeId int;

				  UPDATE TEMP_Students SET GradeId = 1;"
			);

			// Drop the existing table.
			migrationBuilder.DropTable(
				name: "Students");

			// Create a new table with the attributes we want.
			migrationBuilder.CreateTable(
				name: "Students",
				columns: table => new
				{
					Id = table.Column<int>(nullable: false)
						.Annotation("Sqlite:Autoincrement", true),
					StudentName = table.Column<string>(nullable: true),
					GradeId = table.Column<int>(nullable: false),
				},
				constraints: table =>
				{
					table.PrimaryKey("PK_Students", x => x.Id);
					table.ForeignKey(
						name: "FK_Students_Grades_GradeId",
						column: x => x.GradeId,
						principalTable: "Grades",
						principalColumn: "Id",
						onDelete: ReferentialAction.Cascade);
				}
			);
			migrationBuilder.CreateIndex(
				name: "IX_Students_GradeId",
				table: "Students",
				column: "GradeId");

			// Copy the data from the temp table to the new table.
			migrationBuilder.Sql(
				@"INSERT INTO Students
				  (
					Id,
					StudentName,
					GradeId
				  )
				  SELECT Id,
				         StudentName,
				         GradeId
				  FROM TEMP_Students;

				  PRAGMA foreign_keys = on;"
			);

			// Drop the temp table.
			migrationBuilder.DropTable(
				name: "TEMP_Students");
		}

		protected override void Down(MigrationBuilder migrationBuilder)
		{
#if false
			// These three statements are what was generated by the tool.
			// They will not work as-is.
			migrationBuilder.DropForeignKey(
				name: "FK_Students_Grades_GradeId",
				table: "Students");
			
			migrationBuilder.DropIndex(
				name: "IX_Students_GradeId",
				table: "Students");

			migrationBuilder.DropColumn(
				name: "GradeId",
				table: "Students");

			// Do things manually.
			// This implementation uses a hybrid of EFCore methods
			// and SQL commands. I want the sample to use SQL
			// only (see below) but I also want to leave this here
			// because it might be useful.

			// Copy the existing table data to a temp table.
			migrationBuilder.Sql(
				@"CREATE TABLE TEMP_Students AS SELECT *
				                                FROM Students;"
			);

			// Drop the existing table.
			migrationBuilder.DropTable(
				name: "Students");

			// Create a new table with the attributes we want.
			migrationBuilder.CreateTable(
				name: "Students",
				columns: table => new
				{
					Id = table.Column<int>(nullable: false)
						.Annotation("Sqlite:Autoincrement", true),
					StudentName = table.Column<string>(nullable: true)
				},
				constraints: table =>
				{
					table.PrimaryKey("PK_Students", x => x.Id);
				}
			);

			// Copy the data from the temp table to the new table.
			migrationBuilder.Sql(
				@"INSERT INTO Students
				  (
					Id,
					StudentName
				  )
				  SELECT Id,
				         StudentName
				  FROM TEMP_Students;"
			);

			// Drop the temp table.
			migrationBuilder.DropTable(
				name: "TEMP_Students");

			migrationBuilder.DropTable(
				name: "Grades");
#else
			// SQLite doesn't support DropForeignKey or DropColumn,
			// so we need to handle the whole thing ourselves.
			// 1. Create a temp Students table and copy the existing
			//    Student data to it.
			// 2. Drop the existing Students table.
			// 3. Create a new Students table using the format we want.
			//    (i.e. no GradeId foreign key).
			// 4. Copy the data from the temp table to the new table
			//    (ignoring GradeId of course).
			//
			// NOTE: I tried "DROP INDEX Students.IX_Students_GradeId;"
			// but Update-Database gives me an error saying there is no
			// such index. I couldn't figure out why it was doing this,
			// since the index is clearly created in Up(). I decided to
			// just ignore it, since the first migration doesn't explicitly
			// DROP the indexes it created; presumably dropping the table
			// also drops the indexes in that table.
			migrationBuilder.Sql(
				@"CREATE TABLE TEMP_Students AS SELECT *
				                                FROM Students;

				  DROP TABLE Students;

				  CREATE TABLE Students
				  (
					Id INTEGER NOT NULL CONSTRAINT PK_Students PRIMARY KEY AUTOINCREMENT,
					StudentName TEXT NULL
				  );

				  INSERT INTO Students
				  (
					Id,
					StudentName
				  )
				  SELECT Id,
				         StudentName
				  FROM TEMP_Students;

				  DROP TABLE TEMP_Students;

				  DROP TABLE Grades;"
			);
#endif
		}
	}
}
